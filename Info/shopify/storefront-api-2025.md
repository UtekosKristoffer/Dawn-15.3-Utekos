Storefront API Client

Initialization
Public access token client initialization
import {createStorefrontApiClient} from '@shopify/storefront-api-client';

const client = createStorefrontApiClient({
  storeDomain: 'http://your-shop-name.myshopify.com',
  apiVersion: '2023-10',
  publicAccessToken: 'your-storefront-public-access-token',
});
Create a server enabled client using a private access token and a custom Fetch API
Warning

Private Storefront API delegate access tokens should only be used in server-to-server implementations and not within a browser environment.

In order to use the client within a server, a server enabled JS Fetch API will need to be provided to the client at initialization.

import {
  createStorefrontApiClient,
  CustomFetchApi,
} from '@shopify/storefront-api-client';
import {fetch as nodeFetch} from 'node-fetch';

const client = createStorefrontApiClient({
  storeDomain: 'http://your-shop-name.myshopify.com',
  apiVersion: '2023-10',
  privateAccessToken: 'your-storefront-private-access-token',
  customFetchApi: nodeFetch,
});
createStorefrontApiClient() parameters
Property	Type	Description
storeDomain	string	The domain of the store. It can be the Shopify myshopify.com domain or a custom store domain.
apiVersion	string	The requested Storefront API version
publicAccessToken?	string	Storefront API public access token. Either publicAccessToken or privateAccessToken must be provided at initialization.
privateAccessToken?	string	Storefront API private access token. Either publicAccessToken or privateAccessToken must be provided at initialization.
Important: Storefront API private delegate access tokens should only be used in a server-to-server implementation.
clientName?	string	Name of the client
retries?	number	The number of HTTP request retries if the request was abandoned or the server responded with a Too Many Requests (429) or Service Unavailable (503) response. Default value is 0. Maximum value is 3.
customFetchAPI?	(url: string, init?: {method?: string, headers?: HeaderInit, body?: string}) => Promise<Response>	A replacement fetch function that will be used in all client network requests. By default, the client uses window.fetch().
logger?	(logContent: UnsupportedApiVersionLog |HTTPResponseLog|HTTPRetryLog) => void	A logger function that accepts log content objects. This logger will be called in certain conditions with contextual information.
Client properties
Property	Type	Description
config	StorefrontApiClientConfig	Configuration for the client
getHeaders	(headers?: Record<string, string | string[]>) => Record<string, string | string[]>	Returns Storefront API specific headers needed to interact with the API. If additional headers are provided, the custom headers will be included in the returned headers object.
getApiUrl	(apiVersion?: string) => string	Returns the shop specific API url. If an API version is provided, the returned URL will include the provided version, else the URL will include the API version set at client initialization.
fetch	(operation: string, options?: ApiClientRequestOptions) => Promise<Response>	Fetches data from Storefront API using the provided GQL operation string and ApiClientRequestOptions object and returns the network response.
request	<TData>(operation: string, options?: ApiClientRequestOptions) => Promise<ClientResponse<TData>>	Requests data from Storefront API using the provided GQL operation string and ApiClientRequestOptions object and returns a normalized response object.
requestStream	<TData>(operation: string, options?: RequestOptions) => Promise <AsyncIterator<ClientStreamResponse<TData>>>	Fetches GQL operations (eg. @defer directive) that can result in a streamed response from the Storefront API . The function returns an async iterator and the iterator will return normalized stream response objects as data becomes available through the stream.
StorefrontApiClientConfig properties
Name	Type	Description
storeDomain	string	The secure store domain
apiVersion	string	The Storefront API version to use in the API request
publicAccessToken	string | never	The provided public access token. If privateAccessToken was provided, publicAccessToken will not be available.
privateAccessToken	string | never	The provided private access token. If publicAccessToken was provided, privateAccessToken will not be available.
headers	Record<string, string | string[]>	The headers generated by the client during initialization
apiUrl	string	The API URL generated from the provided store domain and api version
clientName?	string	The provided client name
retries?	number	The number of retries the client will attempt when the API responds with a Too Many Requests (429) or Service Unavailable (503) response
ApiClientRequestOptions properties
Name	Type	Description
variables?	Record<string, any>	Variable values needed in the graphQL operation
apiVersion?	string	The Storefront API version to use in the API request
headers?	Record<string, string | string[]>	Customized headers to be included in the API request
retries?	number	Alternative number of retries for the request. Retries only occur for requests that were abandoned or if the server responds with a Too Many Request (429) or Service Unavailable (503) response. Minimum value is 0 and maximum value is 3.
ClientResponse<TData>
Name	Type	Description
data?	TData | any	Data returned from the Storefront API. If TData was provided to the function, the return type is TData, else it returns type any.
errors?	ResponseErrors	Errors object that contains any API or network errors that occured while fetching the data from the API. It does not include any UserErrors.
extensions?	Record<string, any>	Additional information on the GraphQL response data and context. It can include the context object that contains the context settings used to generate the returned API response.
ClientStreamResponse<TData>
Name	Type	Description
data?	TData | any	Currently available data returned from the Storefront API. If TData was provided to the function, the return type is TData, else it returns type any.
errors?	ResponseErrors	Errors object that contains any API or network errors that occured while fetching the data from the API. It does not include any UserErrors.
extensions?	Record<string, any>	Additional information on the GraphQL response data and context. It can include the context object that contains the context settings used to generate the returned API response.
hasNext	boolean	Flag to indicate whether the response stream has more incoming data
ResponseErrors
Name	Type	Description
networkStatusCode?	number	HTTP response status code
message?	string	The provided error message
graphQLErrors?	any[]	The GraphQL API errors returned by the server
response?	Response	The raw response object from the network fetch call
Client request() response examples
Successful response
API response
{
  "data": {
    "product": {
      "id": "gid://shopify/Product/12345678912",
      "title": "Sample product # 1"
    }
  },
  "extensions": {
    "context": {
      "country": "US",
      "language": "EN"
    }
  }
}
Error responses
Network error
{
  "errors": {
    "networkStatusCode": 401,
    "message": ""
  }
}
Storefront API graphQL error
{
  "errors": {
    "networkStatusCode": 200,
    "message": "An error occurred while fetching from the API. Review the `graphQLErrors` object for details.",
    "graphQLErrors": [
      {
        "message": "Field 'testField' doesn't exist on type 'Product'",
        "locations": [
          {
            "line": 17,
            "column": 3
          }
        ],
        "path": ["fragment ProductFragment", "testField"],
        "extensions": {
          "code": "undefinedField",
          "typeName": "Product",
          "fieldName": "testField"
        }
      }
    ]
  }
}
Usage examples
Query for a product
const productQuery = `
  query ProductQuery($handle: String) {
    product(handle: $handle) {
      id
      title
      handle
    }
  }
`;

const {data, errors, extensions} = await client.request(productQuery, {
  variables: {
    handle: 'sample-product',
  },
});
Query for product info using the @defer directive
const productQuery = `
  query ProductQuery($handle: String) {
    product(handle: $handle) {
      id
      handle
      ... @defer(label: "deferredFields") {
        title
        description
      }
    }
  }
`;

const responseStream = await client.requestStream(productQuery, {
  variables: {handle: 'sample-product'},
});

// await available data from the async iterator
for await (const response of responseStream) {
  const {data, errors, extensions, hasNext} = response;
}
Create a localized cart
const cartCreateMutation = `
  mutation ($input: CartInput!, $country: CountryCode, $language: LanguageCode)
  @inContext(country: $country, language: $language) {
    cartCreate(input: $input) {
      userErrors {
        message
        code
        field
      }
      cart {
        id
        checkoutUrl
      }
    }
  }
`;

const {data, errors, extensions} = await client.request(cartCreateMutation, {
  variables: {
    input: {},
    country: 'JP',
    language: 'JA',
  },
});
Query for shop information
const shopQuery = `
  query shop {
    shop {
      name
      id
    }
  }
`;

const {data, errors, extensions} = await client.request(shopQuery);
Dynamically set the Storefront API version per request
const productQuery = `
  query ProductQuery($handle: String) {
    product(handle: $handle) {
      id
      title
      handle
    }
  }
`;

const {data, errors, extensions} = await client.request(productQuery, {
  variables: {
    handle: 'sample-product',
  },
  apiVersion: '2023-07',
});
Add custom headers to API request
const productQuery = `
  query ProductQuery($handle: String) {
    product(handle: $handle) {
      id
      title
      handle
    }
  }
`;

const {data, errors, extensions} = await client.request(productQuery, {
  variables: {
    handle: 'sample-product',
  },
  headers: {
    'Shopify-Storefront-Id': 'shop-id',
  },
});
Dynamically set the number of retries per request
const productQuery = `
  query ProductQuery($handle: String) {
    product(handle: $handle) {
      id
      title
      handle
    }
  }
`;

const {data, errors, extensions} = await client.request(productQuery, {
  variables: {
    handle: 'sample-product',
  },
  retries: 2,
});
Provide GQL query type to client.request() and client.requestStream()
import {print} from 'graphql/language';

// GQL operation types are usually auto generated during the application build
import {CollectionQuery, CollectionDeferredQuery} from 'types/appTypes';
import collectionQuery from './collectionQuery.graphql';
import collectionDeferredQuery from './collectionDeferredQuery.graphql';

const {data, errors, extensions} = await client.request<CollectionQuery>(
  print(collectionQuery),
  {
    variables: {
      handle: 'sample-collection',
    },
  },
);

const responseStream = await client.requestStream<CollectionDeferredQuery>(
  print(collectionDeferredQuery),
  {
    variables: {handle: 'sample-collection'},
  },
);
Using client.fetch() to get API data
const shopQuery = `
  query shop {
    shop {
      name
      id
    }
  }
`;

const response = await client.fetch(shopQuery);

if (response.ok) {
  const {errors, data, extensions} = await response.json();
}
Typing variables and return objects
This client is compatible with the @shopify/api-codegen-preset package. You can use that package to create types from your operations with the Codegen CLI.

There are different ways to configure codegen with it, but the simplest way is to:

Add the preset package as a dev dependency to your project, for example:

npm install --save-dev @shopify/api-codegen-preset
Create a .graphqlrc.ts file in your root containing:

import {ApiType, shopifyApiProject} from '@shopify/api-codegen-preset';

export default {
  schema: 'https://shopify.dev/storefront-graphql-direct-proxy',
  documents: ['*.ts', '!node_modules'],
  projects: {
    default: shopifyApiProject({
      apiType: ApiType.Storefront,
      apiVersion: '2023-10',
      outputDir: './types',
    }),
  },
};
Add "graphql-codegen": "graphql-codegen" to your scripts section in package.json.

Tag your operations with #graphql, for example:

const {data, errors, extensions} = await client.request(
  `#graphql
  query Shop {
    shop {
      name
    }
  }`,
);
console.log(data?.shop.name);
Run npm run graphql-codegen to parse the types from your operations.

Note

Remember to ensure that your tsconfig includes the files under ./types!

Once the script runs, it'll create the file ./types/storefront.generated.d.ts. When TS includes that file, it'll automatically cause the client to detect the types for each query.

Log Content Types
UnsupportedApiVersionLog
This log content is sent to the logger whenever an unsupported API version is provided to the client.

Property	Type	Description
type	LogType['Unsupported_Api_Version']	The type of log content. Is always set to Unsupported_Api_Version
content	{apiVersion: string, supportedApiVersions: string[]}	Contextual info including the provided API version and the list of currently supported API versions.
HTTPResponseLog
This log content is sent to the logger whenever a HTTP response is received by the client.

Property	Type	Description
type	LogType['HTTP-Response']	The type of log content. Is always set to HTTP-Response
content	{requestParams: [url, init?], response: Response}	Contextual data regarding the request and received response
HTTPRetryLog
This log content is sent to the logger whenever the client attempts to retry HTTP requests.

Property	Type	Description
type	LogType['HTTP-Retry']	The type of log content. Is always set to HTTP-Retry
content	{requestParams: [url, init?], lastResponse?: Response, retryAttempt: number, maxRetries: number}	Contextual data regarding the upcoming retry attempt.

requestParams: parameters used in the request
lastResponse: previous response
retryAttempt: the current retry attempt count
maxRetries: the maximum number of retries
RequestParams
Property	Type	Description
url	string	Requested URL
init?	{method?: string, headers?: HeaderInit, body?: string}	The request information
Gotchas / Troubleshooting
URL validation errors when using React Native
If you're using this package in a React Native project, you might encounter URL validation errors when initializing the storefront api client. For example:

Error: Storefront API Client: a valid store domain ("http://shop.myshopify.com/") must be provided
To avoid issues:

Install the react-native-url-polyfill package:
npm i react-native-url-polyfill
Add the following import to the top of your entry file, typically index.js:
import 'react-native-url-polyfill/auto';
This will apply a global polyfill for the URL object, allowing you to instantiate the storefront api client without encountering URL validation errors.
GraphQL Storefront API
Create unique customer experiences with the Storefront API on any platform, including the web, apps, and games. 
The API offers a full range of commerce options making it possible for customers to view products and collections, a
dd products to a cart, and check out.

Explore Hydrogen, Shopify’s official React-based framework for building headless commerce at global scale.




Endpoints and queries
The Storefront API is available only in GraphQL. There's no REST API for storefronts.

All Storefront API queries are made on a single GraphQL endpoint, which only accepts POST requests:

https://{store_name}.myshopify.com/api/2025-07/graphql.json

Anchor to VersioningVersioning
The Storefront API is versioned, with new releases four times a year. To keep your app stable, make sure that you specify a supported version in the URL.

Anchor to GraphiQL explorerGraphiQL explorer
Explore and learn Shopify's Storefront API using the GraphiQL explorer. To build queries and mutations with shop data, install Shopify's GraphiQL app.

Anchor to Usage limitationsUsage limitations
Shopify Plus bot protection is only available for the Cart object. It isn't available for the Checkout object.
You can't use Storefront API to duplicate existing Shopify functionality—be sure to check the API terms of service before you start.

const productQuery = `
  query ProductQuery($handle: String) {
    product(handle: $handle) {
      id
      title
      handle
    }
  }
`;

const {data, errors, extensions} = await client.request(productQuery, {
  variables: {
    handle: 'sample-product',
  },
});



Directives
A directive provides a way for apps to describe additional options to the GraphQL executor. 
It lets GraphQL change the result of the query or mutation based on the additional information provided by the directive.
@Defer
The @defer directive allows clients to prioritize part of a GraphQL query without having to 
make more requests to fetch the remaining information. It does this through streaming, where the first response contains the data that isn't deferred.
The directive accepts two optional arguments: label and if. The label is included 
in the fragment response if it's provided in the directive. When the if argument is false, the fragment isn't deferred.
This example shows how to return a product's title and description immediately, and then return the descriptionHtml and 
options after a short delay.
The @defer directive is available as a developer preview in unstable.

Optimize a query using @defer
The @defer directive can be applied to fragment spreads and inline fragments in a GraphQL query. 
Fields cannot use @defer directly.

Many client libraries support @defer in two ways: after each response is received, 
or once all responses have been received. To get the benefits of @defer it's strongly suggested to handle each response as it arrives, so the client can begin rendering as soon as possible.

The following example retrieves details about a product before the list of related products. It uses @defer to 
deprioritize the productRecommendations query, but still receive those recommendations afterward without making an additional request. Each response (including the undeferred part) begins with --graphql.
POST https://{shop}.myshopify.com/api/{api_version}/graphql.json

query product($productId: ID!) {
  product(id: $productId) {
    id
    title
  }
  ... relatedProducts @defer
}

fragment relatedProducts on QueryRoot {
  productRecommendations(productId: $productId) {
    id
    title
  }
}

Response:
content-type: multipart/mixed; boundary=graphql

--graphql
Content-Type: application/json
Content-Length: 108

{
  "data":{
    "product": {
      "id": "gid://shopify/Product/191637365",
      "title": "Black Dot Dress Shirt"
    }
  },
  "hasNext": true
}

--graphql
Content-Type: application/json
Content-Length: 286

{
  "incremental": [
    {
      "path": [],
      "data": {
        "productRecommendations": [
          { "id": "gid://shopify/Product/1328794861624", "title": "Baseball t-shirt" },
          { "id": "gid://shopify/Product/1328794894392", "title": "Fancy t-shirt" },
          { "id": "gid://shopify/Product/1328795091000", "title": "Sports t-shirt" }
        ]
      }
    }
  ],
  "hasNext": false
}

--graphql--

Fetching carrier-calculated rates for the cart using @defer
As of 2024-07, Cart#deliveryGroups supports a new withCarrierRates argument, used to indicate intent to fetch carrier-calculated rates. This capability requires mandatory use of @defer directive to ensure that the calculation of the delivery rates does not delay the cart response.

When fetching the delivery groups using withCarrierRates: true inside a @defer fragment, the cart will initially calculate (excluding the delivery rates) and resolve the response, and then stream the fragment containing the rates once they're available.
query cart($cartId: ID!) {
  cart(id: $cartId) {
    cost {
      subtotalAmount {
        amount
        currencyCode
      }
      totalAmount {
        amount
        currencyCode
      }
    }
    ... DeliveryGroups @defer
  }
}

fragment DeliveryGroups on Cart {
  deliveryGroups(first: 10, withCarrierRates: true) {
    edges {
      node {
        deliveryOptions {
          title
          handle
          estimatedCost {
            amount
            currency
          }
        }
        selectedDeliveryOption {
          title
          handle
          estimatedCost {
            amount
            currencyCode
          }
        }
      }
    }
  }
}

--graphql
Content-Type: application/json
Content-Length: 156

{
  "data": {
    "cart": {
      "cost": {
        "subtotalAmount": {
          "amount": "155.99",
          "currencyCode": "CAD"
        },
        "totalAmount": {
          "amount": "155.99",
          "currencyCode": "CAD"
        }
      }
    }
  },
  "hasNext": true
}

--graphql
Content-Type: application/json
Content-Length: 271

{
  "incremental": [
    {
      "path": [
        "cart"
      ],
      "data": {
        "deliveryGroups": {
          "edges": [
            {
              "node": {
                "deliveryOptions": [
                  {
                    "title": "Priority",
                    "handle": "b709d6e6b08ffb9d93d8bc0a23d76d44",
                    "estimatedCost": {
                      "amount": "21.86",
                      "currencyCode": "CAD"
                    }
                  }
                ],
                "selectedDeliveryOption": null
              }
            }
          ]
        }
      }
    }
  ],
  "hasNext": false
}

--graphql--

In the provided example, the first response fragment contains the non-deferred cart data, which is returned without delay from the pending carrier-calculated rates. Once the rates become available, the server returns the available delivery groups of the cart in the second fragment using the @defer protocol.

Note
Fetching the carrier-calculated rates will not automatically select a delivery option. To select a carrier-calculated rate, please refer to cartSelectedDeliveryOptionsUpdate. Furthermore, the cost field is not updated when fetching of carrier-calculated rates.
@inContext (Buyer Identity)
In the Storefront API, beyond version 2024-04, the @inContext directive can contextualize any query to a logged in buyer of a shop with an optional buyer argument.

This example shows how to return a product's price amount contextualized for a business customer buyer @inContext(buyer: {customerAccessToken: 'token', companyLocationId: 'gid://shopify/CompanyLocation/1'}).

Example for supporting a contextualized buyer identity
GraphQL directives spec

Contextualize Storefront API Requests
Including the buyer argument on the @inContext directive will contextualize any Storefront API queries for a B2B customer. Any queries and mutations that need to be contextualized should be updated to include a buyer. Use the customerAccessToken and companyLocationId that you obtained in Step 1 and Step 2.

With a contextualized query, you can access a quantityRule and quantityPriceBreaks on a product variant, as well as get a price that's contextualized for the B2B customer.

Contextualized RecommendedProducts Query
GraphQL mutation
Copy
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
query RecommendedProducts (
   $buyer: BuyerInput
) @inContext(buyer: $buyer) {
   products(first: 5) {
     nodes {
       id
       variants(first: 5) {
        nodes {
          id
          quantityRule {
            maximum
            minimum
            increment
          }
          quantityPriceBreaks(first: 5) {
            nodes {
              minimumQuantity
              price {
                amount
                currencyCode
              }
            }
          }
        }
      }
    }
  }
}
Variables
Copy
1
2
3
4
"buyer": {
   "customerAccessToken": "shpsb_eyJh123456789",
   "companyLocationId": "gid://shopify/CompanyLocation/10079785100",
}
Note
The buyer and country arguments for @inContext are ignored for cart queries. In order to get a contextualized cart, follow Step 4: Set the Buyer Identity on Cart to explicitly set the buyer identity with cartBuyerIdentityUpdate or during cartCreate. Other arguments on the @inContext directive (language) will still work as expected for cart queries.

Anchor to Step 4: Set the Buyer Identity on CartStep 4: Set the Buyer Identity on Cart
Include buyer identity on cart with the storefront customerAccessToken from an authenticated user and the companyLocationId. For more details on carts, see the Create and update a cart with the Storefront API guide.

Call the cartCreate mutation. The buyerIdentity argument should be supplied with the input fields customerAccessToken and companyLocationId.

Setting Buyer Identity on Cart
GraphQL mutation

mutation cartCreate {
  cartCreate {
    cart {
      # Cart fields
    }
    userErrors {
      field
      message
    }
  }
}
Variables
{
  "buyerIdentity": {
    "customerAccessToken": "shpsb_eyJh123456789",
    "companyLocationId": "gid://shopify/CompanyLocation/10079785100",
  }
}
The cartBuyerIdentityUpdate mutation also supports a buyerIdentity argument. Use this mutation to update and existing cart with the customerAccessToken and companyLocationId.

Caution
Updating the buyer identity on an existing cart with added products may result in an invalid cart. Products not published for the current B2B customer will be removed from cart. Products that are published, but with new quantity rules, will remain unchanged. Querying the cart will not return an error, but making updates to the cart may result in an error which can be read in the returned userErrors field. If the B2B customer continues to checkout with an invalid cart, the issues will be displayed as an error message.

Anchor to (Optional) Building a gated B2B store(Optional) Building a gated B2B store
With headless you have the flexibility to gate specific features to B2B customers. For example, you can, allow potential B2B customers to view products, but without prices or the ability to order.

When querying for a product, only include the price if there is a logged in session (valid customerAccessToken with a saved companyLocationId). Only show the "add to cart" button if there is a logged in session (valid customerAccessToken with a saved companyLocationId).


